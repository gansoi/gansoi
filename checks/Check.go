package checks

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/Knetic/govaluate"
	"github.com/go-playground/validator/v10"

	"github.com/gansoi/gansoi/database"
	"github.com/gansoi/gansoi/plugins"
	"github.com/gansoi/gansoi/transports"
)

type (
	// Check defines a check to be conducted by Gansoi.
	Check struct {
		database.Object `storm:"inline"`
		Name            string          `json:"name" validate:"required"`
		AgentID         string          `json:"agent" validate:"required"`
		Hosts           []string        `json:"hosts"`
		Interval        time.Duration   `json:"interval"`
		Arguments       json.RawMessage `json:"arguments"`
		Expressions     []string        `json:"expressions"`
		ContactGroups   []string        `json:"contactgroups"`
	}
)

// RunCheck will run a check and return a CheckResult.
func RunCheck(transport transports.Transport, check *Check) (checkResult *CheckResult) {
	agentResult := plugins.NewAgentResult()
	checkResult = &CheckResult{
		TimeStamp: time.Now(),
		Results:   agentResult,
	}

	defer func() {
		err := recover()

		if err != nil {
			// We don't know the type of 'err', so we let fmt deal with it :)
			checkResult.Error = fmt.Sprintf("%s", err)
		}
	}()

	agent := plugins.GetAgent(check.AgentID)
	err := json.Unmarshal(check.Arguments, &agent)
	if err != nil {
		checkResult.Error = err.Error()
		return checkResult
	}

	switch a := agent.(type) {
	case plugins.RemoteAgent:
		if transport == nil {
			checkResult.Error = "no host"
			return checkResult
		}

		err = a.RemoteCheck(transport, agentResult)
	case plugins.Agent:
		err = a.Check(agentResult)
	}

	if err != nil {
		checkResult.Error = err.Error()
		return checkResult
	}

	// If any expressions is defined, we try to evaluate them until one fails.
	if len(check.Expressions) > 0 {
		err = check.Evaluate(agentResult)
	}

	if err != nil {
		checkResult.Error = err.Error()
	}

	return checkResult
}

// Evaluate will evaluate the CheckResult based on a slice of expressions.
func (c *Check) Evaluate(result plugins.AgentResult) error {
	for _, exp := range c.Expressions {
		e, err := govaluate.NewEvaluableExpression(exp)
		if err != nil {
			return err
		}

		result, err := e.Evaluate(result)
		if err != nil {
			return err
		}

		// This is a nifty go trick. If result is NOT a bool, this will assign
		// a default bool (false) value to checkResult.Passed - and not panic.
		passed, _ := result.(bool)

		// On first false evaluation, we skip the rest of the tests. We already
		// failed.
		if !passed {
			return fmt.Errorf("(%s) failed", exp)
		}
	}

	return nil
}

// Validate implements database.Validator.
func (c *Check) Validate(_ database.Reader) error {
	v := validator.New()
	return v.Struct(c)
}
